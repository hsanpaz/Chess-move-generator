!function(f){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=f();else if("function"==typeof define&&define.amd)define([],f);else{("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this).moveGenerator=f()}}(function(){return function(){return function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){return o(e[i][1][r]||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}}()({1:[function(require,module,exports){const{Board:Board}=require("./Game.js");class chessMove{constructor(){}static getValidMoves(board,isFen=!1){let boardObj;return boardObj=isFen?new Board(board,isFen):new Board(board),{algebraicMoves:Array.from(boardObj.algebraicMoves),isCheck:boardObj.isCheck()}}}module.exports={chessMove:chessMove},global=chessMove},{"./Game.js":2}],2:[function(require,module,exports){const EMPTY_SQUARE="-",BLACK_ROOK="r",BLACK_BISHOP="b",BLACK_KNIGHT="n",BLACK_QUEEN="q",BLACK_KING="k",BLACK_PAWN="p",WHITE_ROOK="R",WHITE_BISHOP="B",WHITE_KNIGHT="N",WHITE_QUEEN="Q",WHITE_KING="K",WHITE_PAWN="P",WHITE="w",BLACK="b",BISHOP_MOVE_DIRECTIONS=[9,11,-9,-11],KNIGHT_MOVE_DIRECTIONS=[-12,-21,-19,-8,12,21,19,8],KING_QUEEN_MOVE_DIRECTIONS=[-1,-11,-10,-9,1,11,10,9],ROOK_MOVE_DIRECTIONS=[-1,1,-10,10],WHITE_PAWN_STARTING_MOVE_DIRECTIONS=[-10,-20],BLACK_PAWN_STARTING_MOVE_DIRECTIONS=[10,20],WHITE_PAWN_MOVED_MOVE_DIRECTIONS=[-10],BLACK_PAWN_MOVED_MOVE_DIRECTIONS=[10],whitePieces=new Set([WHITE_ROOK,WHITE_BISHOP,WHITE_KNIGHT,WHITE_QUEEN,WHITE_KING,WHITE_PAWN]),blackPieces=new Set([BLACK_ROOK,BLACK_BISHOP,BLACK_KNIGHT,BLACK_QUEEN,BLACK_KING,BLACK_PAWN]),isWhite=piece=>whitePieces.has(piece),isBlack=piece=>blackPieces.has(piece),BIT_ON="1",BIT_OFF="0",CURRENT_TURN_BLACK_BIT=100,START_POSITION="00000000000rnbqkbnr00pppppppp00--------00--------00--------00--------00PPPPPPPP00RNBQKBNR0000000000001111000000",positionString=(from,to)=>`${from}-${to}`,movedToPositionFromString=move=>Number(move.split(EMPTY_SQUARE)[1]),movedFromPositionFromString=move=>Number(move.split(EMPTY_SQUARE)[0]),canCastleKingSide=(position,board,color)=>{if(board[position+1]===EMPTY_SQUARE&&board[position+2]===EMPTY_SQUARE){if(color===WHITE){const whiteKingHasMoved=board[105]===BIT_ON,whiteKingSideRookHasMoved=board[102]===BIT_ON;return!(whiteKingHasMoved||whiteKingSideRookHasMoved)}{const blackKingHasMoved=board[106]===BIT_ON,blackKingSideRookHasMoved=board[104]===BIT_ON;return!(blackKingHasMoved||blackKingSideRookHasMoved)}}return!1},canCastleQueenSide=(position,board,color)=>{if(board[position-1]===EMPTY_SQUARE&&board[position-2]===EMPTY_SQUARE&&board[position-3]===EMPTY_SQUARE){if(color===WHITE){const whiteKingHasMoved=board[105]===BIT_ON,whiteQueenSideRookHasMoved=board[101]===BIT_ON;return!(whiteKingHasMoved||whiteQueenSideRookHasMoved)}{const blackKingHasMoved=board[106]===BIT_ON,blackQueenSideRookHasMoved=board[103]===BIT_ON;return!(blackKingHasMoved||blackQueenSideRookHasMoved)}}return!1},getNextBoardPosition=(board,pos,replacement)=>board.substr(0,parseInt(pos))+replacement+board.substr(parseInt(pos)+1),testMove=(move,board,withLastMove)=>{let from=movedFromPositionFromString(move),to=movedToPositionFromString(move),placePiece=getNextBoardPosition(board,to,board[from]),removePiece=getNextBoardPosition(placePiece,from,EMPTY_SQUARE),changedTurn=getNextBoardPosition(removePiece,CURRENT_TURN_BLACK_BIT,board[CURRENT_TURN_BLACK_BIT]===BIT_ON?BIT_OFF:BIT_ON);if(withLastMove){let board=changedTurn;const fromTens=String(from)[0],fromOnes=String(from)[1],toTens=String(to)[0],toOnes=String(to)[1];return board=getNextBoardPosition(board,107,fromTens),board=getNextBoardPosition(board,108,fromOnes),board=getNextBoardPosition(board,109,toTens),board=getNextBoardPosition(board,110,toOnes)}return changedTurn};const BOARD_EQUIVALENT_SQUARES=["0"," 0"," 0"," 0"," 0"," 0"," 0"," 0"," 0","0","0","a8","b8","c8","d8","e8","f8","g8","h8","0","0","a7","b7","c7","d7","e7","f7","g7","h7","0","0","a6","b6","c6","d6","e6","f6","g6","h6","0","0","a5","b5","c5","d5","e5","f5","g5","h5","0","0","a4","b4","c4","d4","e4","f4","g4","h4","0","0","a3","b3","c3","d3","e3","f3","g3","h3","0","0","a2","b2","c2","d2","e2","f2","g2","h2","0","0","a1","b1","c1","d1","e1","f1","g1","h1","0","0"," 0"," 0"," 0"," 0"," 0"," 0"," 0"," 0","0"];module.exports={Board:class{constructor(board=START_POSITION,isFen){this.board=board,this.enPassant="",isFen&&(this.board=this.getFromFen(board)),this.currentTurn=this.board[CURRENT_TURN_BLACK_BIT]===BIT_ON?BLACK:WHITE,this.legalMoves=this.findLegalMoves(this.board,this.currentTurn),this.algebraicMoves=this.getAlgebraicMoves(this.legalMoves)}getFromFen(fen){var fenFields=fen.split(" "),board="",boardRow="0";fenFields[0].split("/").forEach(function(row){for(let j=0;j<row.length;j++){let piece=row[j];-1!=="12345678".indexOf(piece)?boardRow+=EMPTY_SQUARE.repeat(piece):boardRow+=piece}board+=boardRow+="0",boardRow="0"}),board="0000000000"+board+"0000000000";var flags="";return flags+=fenFields[1]==BLACK?BIT_ON:BIT_OFF,flags+=-1!=fenFields[2].indexOf(WHITE_KING)?BIT_ON:BIT_OFF,flags+=-1!=fenFields[2].indexOf(BLACK_KING)?BIT_ON:BIT_OFF,flags+=-1!=fenFields[2].indexOf(WHITE_QUEEN)?BIT_ON:BIT_OFF,flags+=-1!=fenFields[2].indexOf(BLACK_QUEEN)?BIT_ON:BIT_OFF,flags+="0".repeat(6),board+=flags,this.enPassant=fenFields[3]!=EMPTY_SQUARE?BOARD_EQUIVALENT_SQUARES.indexOf(fenFields[3]):EMPTY_SQUARE,board}getAlgebraicMoves(legalMoves){let from,fromStr,to,algebraicMoves=[],toStr="";return legalMoves.forEach(element=>{[fromStr,toStr]=element.split("-"),from=BOARD_EQUIVALENT_SQUARES[parseInt(fromStr)],to=BOARD_EQUIVALENT_SQUARES[parseInt(toStr)];let obj={};obj[from]=to,algebraicMoves.push(obj)}),algebraicMoves}castle(from,to){from>to?(this.board=getNextBoardPosition(this.board,to+1,this.board[from-4]),this.board=getNextBoardPosition(this.board,from-4,EMPTY_SQUARE)):(this.board=getNextBoardPosition(this.board,to-1,this.board[from+3]),this.board=getNextBoardPosition(this.board,from+3,EMPTY_SQUARE))}findLegalMoves(board=this.board,currentTurn=this.currentTurn){let legalMoves=[];for(let i=0;i<board.length;i++)switch(board[i]){case BLACK_ROOK:currentTurn===BLACK&&(legalMoves=legalMoves.concat(this.getRookMoves(i,board,currentTurn)));break;case BLACK_KNIGHT:currentTurn===BLACK&&(legalMoves=legalMoves.concat(this.getKnightMoves(i,board,currentTurn)));break;case BLACK_BISHOP:currentTurn===BLACK&&(legalMoves=legalMoves.concat(this.getBishopMoves(i,board,currentTurn)));break;case BLACK_QUEEN:currentTurn===BLACK&&(legalMoves=legalMoves.concat(this.getQueenMoves(i,board,currentTurn)));break;case BLACK_KING:currentTurn===BLACK&&(legalMoves=legalMoves.concat(this.getKingMoves(i,board,currentTurn)));break;case BLACK_PAWN:currentTurn===BLACK&&(legalMoves=legalMoves.concat(this.getPawnMoves(i,board,currentTurn)));break;case WHITE_ROOK:currentTurn===WHITE&&(legalMoves=legalMoves.concat(this.getRookMoves(i,board,currentTurn)));break;case WHITE_KNIGHT:currentTurn===WHITE&&(legalMoves=legalMoves.concat(this.getKnightMoves(i,board,currentTurn)));break;case WHITE_BISHOP:currentTurn===WHITE&&(legalMoves=legalMoves.concat(this.getBishopMoves(i,board,currentTurn)));break;case WHITE_QUEEN:currentTurn===WHITE&&(legalMoves=legalMoves.concat(this.getQueenMoves(i,board,currentTurn)));break;case WHITE_KING:currentTurn===WHITE&&(legalMoves=legalMoves.concat(this.getKingMoves(i,board,currentTurn)));break;case WHITE_PAWN:currentTurn===WHITE&&(legalMoves=legalMoves.concat(this.getPawnMoves(i,board,currentTurn)))}return legalMoves.filter(el=>!this.isCheck(currentTurn,testMove(el,board)))}getBishopMoves(position,board,color){return this.getSlidingPiecesMovements(position,board,color,BISHOP_MOVE_DIRECTIONS)}getColor(position,board=this.board){const square=board[position];return isWhite(square)?WHITE:!!isBlack(square)&&BLACK}getKnightMoves(position,board,color){return this.getSteppingPiecesMovements(position,board,color,KNIGHT_MOVE_DIRECTIONS)}getKingMoves(position,board,color,checkCastle=!0){let legalMoves=[];return checkCastle&&canCastleKingSide(position,board,color)&&!1===this.squareHasAttackers(position,board,color)&&!1===this.squareHasAttackers(position+1,board,color)&&legalMoves.push(positionString(position,position+2)),checkCastle&&canCastleQueenSide(position,board,color)&&!1===this.squareHasAttackers(position,board,color)&&!1===this.squareHasAttackers(position-1,board,color)&&legalMoves.push(positionString(position,position-2)),legalMoves.concat(this.getSteppingPiecesMovements(position,board,color,KING_QUEEN_MOVE_DIRECTIONS))}getPawnMovements(position,board,color,increments){let legalMoves=[];for(let i=0;i<increments.length;i++){let pointer=position+increments[i];if(board[pointer]!==EMPTY_SQUARE)break;legalMoves.push(positionString(position,pointer))}let leftCapture=this.getColor(position+increments[0]-1,board),rightCapture=this.getColor(position+increments[0]+1,board);if(leftCapture&&leftCapture!==color&&legalMoves.push(positionString(position,position+increments[0]-1)),rightCapture&&rightCapture!==color&&legalMoves.push(positionString(position,position+increments[0]+1)),this.enPassant!=EMPTY_SQUARE){let pawn=color==WHITE?WHITE_PAWN:BLACK_PAWN;board[this.enPassant-increments[0]-1]==pawn&&legalMoves.push(positionString(this.enPassant-increments[0]-1,this.enPassant)),board[this.enPassant-increments[0]+1]==pawn&&legalMoves.push(positionString(this.enPassant-increments[0]+1,this.enPassant)),this.enPassant=EMPTY_SQUARE}return legalMoves}getPawnMoves(position,board,color){return color===WHITE&&position>70&&position<79?this.getPawnMovements(position,board,color,WHITE_PAWN_STARTING_MOVE_DIRECTIONS):color===BLACK&&position>20&&position<29?this.getPawnMovements(position,board,color,BLACK_PAWN_STARTING_MOVE_DIRECTIONS):color===WHITE?this.getPawnMovements(position,board,color,WHITE_PAWN_MOVED_MOVE_DIRECTIONS):this.getPawnMovements(position,board,color,BLACK_PAWN_MOVED_MOVE_DIRECTIONS)}getQueenMoves(position,board,color){return this.getSlidingPiecesMovements(position,board,color,KING_QUEEN_MOVE_DIRECTIONS)}getRookMoves(position,board,color){return this.getSlidingPiecesMovements(position,board,color,ROOK_MOVE_DIRECTIONS)}getSlidingPiecesMovements(position,board,color,increments){let legalMoves=[];for(let i=0;i<increments.length;i++){let pointer=position;for(;board[pointer];){if(board[pointer+=increments[i]]!==EMPTY_SQUARE){if(this.getColor(pointer,board)&&this.getColor(pointer,board)!==color){legalMoves.push(positionString(position,pointer));break}break}legalMoves.push(positionString(position,pointer))}}return legalMoves}getSteppingPiecesMovements(position,board,color,increments){let legalMoves=[];for(let i=0;i<increments.length;i++){let pointer=position+increments[i];board[pointer]&&(board[pointer]===EMPTY_SQUARE?legalMoves.push(positionString(position,pointer)):this.getColor(pointer,board)&&this.getColor(pointer,board)!==color&&legalMoves.push(positionString(position,pointer)))}return legalMoves}isAttackedBy(moves,board,color,type){return moves.map(move=>movedToPositionFromString(move)).filter(moveToPosition=>board[moveToPosition].toUpperCase()===type.toUpperCase()&&this.getColor(moveToPosition,board)!==color)}findBishopAttackers(position,board,color){const bishopMoves=this.getBishopMoves(position,board,color);return this.isAttackedBy(bishopMoves,board,color,"b")}findKingAttackers(position,board,color){const kingMoves=this.getKingMoves(position,board,color,!1);return this.isAttackedBy(kingMoves,board,color,"k")}findKnightAttackers(position,board,color){const knightMoves=this.getKnightMoves(position,board,color);return this.isAttackedBy(knightMoves,board,color,"n")}findPawnAttackers(position,board,color){const pawnMoves=this.getPawnMoves(position,board,color);return this.isAttackedBy(pawnMoves,board,color,"p")}findQueenAttackers(position,board,color){const queenMoves=this.getQueenMoves(position,board,color);return this.isAttackedBy(queenMoves,board,color,"q")}findRookAttackers(position,board,color){const rookMoves=this.getRookMoves(position,board,color);return this.isAttackedBy(rookMoves,board,color,"r")}isCheck(currentPlayer=this.currentTurn,board=this.board){let kingPos=currentPlayer===WHITE?board.indexOf(WHITE_KING):board.indexOf(BLACK_KING);return this.squareHasAttackers(kingPos,board,currentPlayer)}squareHasAttackers(pos,board,currentPlayer){return this.findBishopAttackers(pos,board,currentPlayer).length>0||this.findRookAttackers(pos,board,currentPlayer).length>0||this.findKnightAttackers(pos,board,currentPlayer).length>0||this.findQueenAttackers(pos,board,currentPlayer).length>0||this.findKingAttackers(pos,board,currentPlayer).length>0||this.findPawnAttackers(pos,board,currentPlayer).length>0}isLegalMove(from,to){return this.legalMoves.indexOf(-1!==positionString(from,to))}},positionString:positionString,movedToPositionFromString:movedToPositionFromString,movedFromPositionFromString:movedFromPositionFromString,testMove:testMove,CURRENT_TURN_BLACK_BIT:CURRENT_TURN_BLACK_BIT,BIT_ON:BIT_ON,BIT_OFF:BIT_OFF,WHITE_QUEENSIDE_ROOK_MOVED_BIT:101,WHITE_KINGSIDE_ROOK_MOVED_BIT:102,BLACK_QUEENSIDE_ROOK_MOVED_BIT:103,BLACK_KINGSIDE_ROOK_MOVED_BIT:104,WHITE_KING_MOVED_BIT:105,BLACK_KING_MOVED_BIT:106,LAST_MOVE_FROM_TENS:107,LAST_MOVE_FROM_ONES:108,LAST_MOVE_TO_TENS:109,LAST_MOVE_TO_ONES:110}},{}]},{},[1])(1)});